1. Why did you choose the tools, libraries, and language you used for the coding exercise?


	I chose Python for this project because it is one of the most accessible and versatile programming languages available, especially for tasks involving JSON parsing. Its rich standard library and simple syntax make it exceptionally fast and efficient to work with for tasks like this, where structured data needs to be handled and processed in a clear, readable way.
	For hosting the API endpoints and designing a RESTful interface, I used Flask. Flask is a lightweight, intuitive framework that allows developers to create web applications and APIs quickly and efficiently. Its simplicity made it an ideal choice for this project, as it allowed me to focus on the core logic of managing points and transactions without unnecessary complexity. Flask also offers excellent extensibility, enabling seamless integration with databases and middleware to support application requirements.
	To manage data storage and retrieval, I used SQLAlchemy to define and interact with database tables for transactions and balances. This approach enabled efficient handling of database operations, such as adding, updating, and querying data, while keeping the code clean and well-structured. By leveraging SQLAlchemy, I could effectively maintain a logical relationship between data entities and ensure the integrity of the application's data.
	Overall, this combination of Python, Flask, and SQLAlchemy provided a straightforward, efficient, and scalable way to implement the solution. Each tool worked well together, supporting a smooth workflow from API design to data management.


2. What are the advantages and disadvantages of your solution?


        One of the main advantages of this solution is its simplicity and readability. By using Python, Flask, and SQLAlchemy, the implementation is easy to understand, maintain, and extend. Flask provides a lightweight framework for designing RESTful APIs, allowing the focus to remain on solving the core problem of managing transactions and balances. SQLAlchemy simplifies database interactions and ensures a clean, structured approach to handling data. Additionally, the solution is efficient and processes transactions in a first in first out order as required, while maintaining accurate balances for quick lookups. Its design also allows for easy scalability and the addition of new features, such as authentication or advanced reporting, if needed.
        A disadvantage of this solution is its reliance on SQLite, which, while convenient for lightweight applications, it’s not ideal for handling high transaction volumes or concurrent requests in a production environment. The current implementation also lacks advanced error handling for scenarios like invalid input, timestamp issues, or concurrent updates, which could lead to unexpected behavior in a real-world setting. While this keeps the solution simple, it limits its suitability for long-term or large-scale use cases without additional enhancements.


3. What has been a favorite school/personal project thus far? What about it that challenged you?


	One of my favorite personal projects so far has been implementing a web application that retrieves and displays NBA player information using an API. In this project, I integrated the API into a Python backend using Flask to display player details such as their position, height, and other stats. I created two specific Flask routes: one to handle user input when a player’s name is entered, which fetched and displayed all matching names from the API in the frontend, and another to allow the user to select a specific player from the list. Once selected, the second method sent a GET request to fetch and display detailed information for that player. Through this project, I gained valuable experience in designing RESTful APIs and building a robust backend to interact seamlessly with a frontend.
	The project was challenging but rewarding. One major challenge was dealing with CORS issues when running the application on a local HTTP server. Initially, I didn’t fully understand what CORS was, but I leveraged online resources to research and solve the problem by importing the CORS package into my script. Another challenge was designing a UI that worked harmoniously with the backend and API restrictions. My original approach caused significant errors due to poor integration, so I had to redesign parts of the application and rethink how the frontend interacted with the backend logic. These challenges taught me a lot about debugging, designing better API-client interactions, and building scalable solutions.